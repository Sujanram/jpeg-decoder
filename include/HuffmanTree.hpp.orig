// Huffman tree abstraction

<<<<<<< HEAD
#ifndef HUFFMAN_TREE_HPP            //Conditional compilation
#define HUFFMAN_TREE_HPP
#include <string>
#include <memory>                   //general utilities to manage dynamic memory
#include "Types.hpp"                //# include 'directive'
=======
#ifndef HUFFMAN_TREE_HPP //Conditional compilation
#define HUFFMAN_TREE_HPP

#include <string>
#include <memory> //general utilities to manage dynamic memory

#include "Types.hpp" //# include 'directive'
>>>>>>> bb118b945c10a6e8ca695115298253cd0182b525

namespace kpeg
{
    // Abstraction for a node in a Huffman tree
    struct Node
    {
        Node() :
         root{ false } ,
         leaf{ false } ,
         code{ "" } ,
         value{ 0x00 } ,
         lChild{ nullptr } ,
         rChild{ nullptr } ,
         parent{ nullptr }
        {}
        
<<<<<<< HEAD
        Node(const std::string _code, const UInt16 _val) :          //a reference to a string object whose contents will not be changed
=======
        Node(const std::string _code, const UInt16 _val) : //a reference to a string object whose contents will not be changed
>>>>>>> bb118b945c10a6e8ca695115298253cd0182b525
         root{ false } ,
         leaf{ false } ,
         code{ _code } ,
         value{ _val } ,
         lChild{ nullptr } ,
         rChild{ nullptr } ,
         parent{ nullptr }
        {}
        
        // Only the root node is set to true
        bool root;

        // Only the leaves with a symbol value are set to true
        bool leaf;

        // The bitstream binary code (e.g., 1101011...)
        std::string code;

        // The symbol (e.g., 0xC3)
        UInt16 value;

        // The left & right children of the node
        //Using Smart pointers
<<<<<<< HEAD
        std::shared_ptr<Node> lChild, rChild;           
=======
        std::shared_ptr<Node> lChild, rChild;
>>>>>>> bb118b945c10a6e8ca695115298253cd0182b525

        // Parent of the node, makes it easier to traverse backwards in the tree
        //Using Smart pointers destructor is automatically called
        std::shared_ptr<Node> parent;
    };
    
    // Alias for a node
    typedef std::shared_ptr<Node> NodePtr;
    
    // Node helpers & operations 
    
    // Create the root node of a Huffman tree
    //UInt16 value = 0xFFFF
<<<<<<< HEAD
    inline NodePtr createRootNode(const UInt16 value)           
    { 
=======
    inline NodePtr createRootNode(const UInt16 value)
    {
>>>>>>> bb118b945c10a6e8ca695115298253cd0182b525
        NodePtr root = std::make_shared<Node>( "", value );
        root->root = true;
        return root;
    }
    
    // Create a node (that is not the root) in a Huffman tree
    inline NodePtr createNode()
    {
        return std::make_shared<Node>();
    }
    
    /* Insert a node as the left child of the specified node
       The value of the child node is specified and a new node  with the same value is created and inserted as the left
       child of the specified node*/
    void insertLeft(NodePtr node, const UInt16 value);
    
<<<<<<< HEAD
     /* Insert a node as the right child of the specified node
=======
    /* Insert a node as the right child of the specified node
>>>>>>> bb118b945c10a6e8ca695115298253cd0182b525
        The value of the child node is specified and a new node with the same value is created and inserted as the right
        child of the specified node */
    void insertRight(NodePtr node, const UInt16 value);
    
    /* Get the node at the immediate  right of the specified
       node, which is also at the same level */
    NodePtr getRightLevelNode(NodePtr node);

    /* Perform inorder traversal of the Huffman
       tree with specified root node */
    void inOrder(NodePtr node);
    
    /* HuffmanTree is an abstraction to manage the binary
     tree constructed from the specified Huffman table.
 
     This class abstracts away the algorithm for
     generating the Huffman binary tree for the
<<<<<<< HEAD
     Huffman tables found in the JFIF file.    */
    class HuffmanTree
    {
        public:
=======
     Huffman tables found in the JFIF file.    */    
    class HuffmanTree
    {
        public:
            
>>>>>>> bb118b945c10a6e8ca695115298253cd0182b525
            // Default constructor
            HuffmanTree();
            
            // Initialize the Huffman tree with specified Huffman table
            // @param htable the Huffman table to use
            HuffmanTree(const HuffmanTable& htable);

            // Create a Huffman tree using specified Huffman table
            // @param htable the Huffman table to use
            void constructHuffmanTree(const HuffmanTable& htable);
            
            // Get the unerlying binray tree that represents the Huffman table
            // @return a pointer to the root node of the underlying binary tree
            const NodePtr getTree() const;
            
            /* Check whether a given Huffman code is present in the tree or not
             NOTE: std::string is used as the return type because 0x0000 and 0xFFFF
             are both values that are used in the normal range. So using them is not 
             possible to indicate special conditions (e.g., code not found in tree) */
            const std::string contains(const std::string& huffCode);
            
        private:
            
            // Root of the binary tree
            NodePtr m_root;
    };
}

<<<<<<< HEAD
#endif //HUFFMAN_TREE_HPP
=======
#endif // HUFFMAN_TREE_HPP
>>>>>>> bb118b945c10a6e8ca695115298253cd0182b525
